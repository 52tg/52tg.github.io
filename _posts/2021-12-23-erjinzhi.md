---
title: 原码反码补码到底怎么回事？如何快速记住他们？
author: huhansome
date: 2021-12-23 17:38:00 +0800
categories: [流弊技能]
tags: [二进制, 原码, 反码, 补码, 计算机原理]
---

首先我们要明白计算机中数字都是以补码的形势存储，运算都是补码运算

机器数：即是数字二进制形势，最高位是符号位0表示正数，1表示负数<br/>
例如3的机器数 0000 0011，-1的机器数是 1000 0001 

真值：即是数字本身的数值，例如 0000 0011 = 3， 1000 0001 = -1 

原码：即是二进制表示，最高位是符号位 所以8bit的数字取值范围就是 [-127, 127]<br/>
反码：正数的反码就是其本身，负数的反码即是符号位不变，其余位取反<br/>
补码：正数的补码就是其本身，负数的补码为其反码+1

计算机为了让数字的符号位也参与计算，所以将减法也做加法

用反码计算，结果是正确的，但是会导致0的符号问题，而且还会有-0 和0的区别，0会有两种表示 0000 0000和 1000 0000，所以为了解决0的符号问题和两个编码表示0的问题，引入用补码来参与计算。所以 【1000 0000】这个补码其实是表示的-128，-128是没得原码和反码的。所以用原码表示范围【-127，127】，但是用补码就能多表示一个最小数-128

~取反 <br/>
 0000 0001  1的补码 <br/>
 1111 1110  1取反 的到的结果，是补码（因为用补码参与运算）<br/>
 1111 1101  补码-1得到反码，由于是负数<br/>
 1000 0010  原码，由于是负数，所以算原码符号位不变 -2<br/>
 
 1000 0010  -2的原码<br/>
 1111 1101  -2的反码<br/>
 1111 1110  -2的补码  用这个补码参与运算取反<br/>
 0000 0001  1的补码，由于正数的补码 反码 原码都一样 
 
 ~n = -(n+1)
 
 ^异或  相同为0 不同为1，不发生进位则可做加法
 
 所以其实可以完全用&和^实现加法
 
 ```
 用异或实现加法  &可以实现求出进位
 int add(int a, int b) {
    if(b == 0) return a;
    int sum = a^b;
    int carry = (a&b)<<1;
    return add(sum, carry);
 }
 ```
 关于二进制中的原码  反码 补码 你都学会了吗？